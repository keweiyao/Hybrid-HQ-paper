#!/usr/bin/env python3

import matplotlib.pyplot as plt
import numpy as np
import argparse
import colorsys
import h5py
import husl
import glob
import os
import subprocess
import pickle
from itertools import chain
from scipy import interpolate
from scipy.optimize import brentq
from matplotlib import ticker
from matplotlib.colors import LinearSegmentedColormap
from matplotlib import patches
from matplotlib import gridspec
from pyfeyn.user import *

aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8.0, 9.25, 10.0
cm1, cm2 = plt.cm.Blues(.8), plt.cm.Reds(.8)
cb,co,cg,cr = plt.cm.Blues(.6), \
	plt.cm.Oranges(.6), plt.cm.Greens(.6), plt.cm.Reds(.6)
offblack = '#262626'
gray = '0.8'

plt.rcdefaults()
plt.rcParams.update({
	'font.family': 'sans-serif',
	'font.serif': ['CMU Serif'],
	'font.size': texsmall,
	'legend.fontsize': texsmall,
	'axes.labelsize': texsmall,
	'axes.titlesize': texsmall,
	'xtick.labelsize': textiny,
	'ytick.labelsize': textiny,
	'font.weight': 400,
	'axes.labelweight': 400,
	'axes.titleweight': 400,
	'lines.linewidth': .9,
	'lines.markersize': 3,
	'lines.markeredgewidth': .1,
	'patch.linewidth': .9,
	'axes.linewidth': .5,
	'xtick.major.width': .5,
	'ytick.major.width': .5,
	'xtick.minor.width': .5,
	'ytick.minor.width': .5,
	'xtick.major.size': 2,
	'ytick.major.size': 2,
	'xtick.minor.size': 1.3,
	'ytick.minor.size': 1.3,
	'xtick.major.pad': 1.8,
	'ytick.major.pad': 1.8,
	'text.color': 'black',
	'axes.edgecolor': 'black',
	'axes.labelcolor': 'black',
	'xtick.color': 'black',
	'ytick.color': 'black',
	'legend.numpoints': 1,
	'legend.scatterpoints': 1,
	'legend.frameon': False,
	'image.interpolation': 'none',
	'pdf.fonttype': 42,
})


plot_functions = {}

def plot(f):
	def wrapper(*args, **kwargs):
		print(f.__name__)
		f(*args, **kwargs)
		plt.savefig('{}.pdf'.format(f.__name__))
		plt.close()

	plot_functions[f.__name__] = wrapper

	return wrapper


def finish(despine=True, remove_ticks=False, pad=0.1, h_pad=None, w_pad=None,
		   rect=[0, 0, 1, 1]):
	fig = plt.gcf()

	for ax in fig.axes:
		if despine:
			for spine in 'top', 'right':
				ax.spines[spine].set_visible(False)

		if remove_ticks:
			for ax_name in 'xaxis', 'yaxis':
				getattr(ax, ax_name).set_ticks_position('none')
		else:
			ax.xaxis.set_ticks_position('bottom')
			ax.yaxis.set_ticks_position('left')

	fig.tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)


def set_loc(ax, xy=None, nbins=5, steps=[1, 2, 3, 4, 5, 10],
			prune=None, minor=0):
	if xy == 'x':
		axes = ax.xaxis,
	elif xy == 'y':
		axes = ax.yaxis,
	else:
		axes = ax.xaxis, ax.yaxis

	for axis in axes:
		axis.set_major_locator(
			ticker.MaxNLocator(nbins=nbins, steps=steps, prune=prune)
		)
		if minor:
			axis.set_minor_locator(ticker.AutoMinorLocator(minor))


def desaturate(color, fraction=0.5):
	h, l, s = colorsys.rgb_to_hls(*color[:3])
	return colorsys.hls_to_rgb(h, l, fraction*s)


def recolor(color, f1=0.7, f2=0.7):
	h, l, s = colorsys.rgb_to_hls(*color[:3])
	return colorsys.hls_to_rgb(h, f1*l, f2*s)


def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):
	new_cmap = LinearSegmentedColormap.from_list(
		'trunc({n},{a:.2f},{b:.2f})'.format(n=cmap.name, a=minval, b=maxval),
		cmap(np.linspace(minval, maxval, n)))
	return new_cmap


TRENTO_LABEL = r'T\raisebox{-.5ex}{R}ENTo'



def alpha_s(Q2, T, mu):
	Nc, Nf = 3., 3.
	pf_g = 4.*np.pi/3.*(Nc+Nf/2.)
	alpha0 = 4.*np.pi/(11. - 2./3.*Nf)
	Lambda2 = 0.2**2
	scale2 = (mu*np.pi*T)**2
	if Q2 < 0:
		result = alpha0/np.log(np.max([-Q2, scale2])/Lambda2)
		if result > alpha0 or result < 0.:
			return alpha0
	else:
		return alpha0*(0.5 - np.arctan(np.log(np.max([Q2, scale2])/Lambda2)/np.pi)/np.pi)
alpha_s = np.vectorize(alpha_s)

def mD2(T, mu):
	return alpha_s(0., T, mu)*6.*np.pi*T*T
mD2 = np.vectorize(mD2)

@plot
def feyn_Qq2Qq(_):
	processOptions()
	fd = FeynDiagram()

	in1 = Point(-4,  2)
	in2 = Point(-4, -2)
	out1 = Point(4, -2)
	out2 = Point(4,  2)
	in_vtx = Vertex(-2, 0, mark=CIRCLE)
	out_vtx = Vertex(2, 0, mark=CIRCLE)

	l1 = Label("Drell-Yan QCD vertex correction", x=0, y=2)

	fa1 = Fermion(in1, in_vtx).addArrow().addLabel(r"\Pelectron")
	fa2 = Fermion(in_vtx, in2).addArrow().addLabel(r"\Ppositron")
	fa2.addParallelArrow(size=0.1, displace=-0.06, sense=-1)
	bos = Photon(in_vtx, out_vtx).addLabel(r"\Pphoton/\PZ")
	fb1 = Fermion(out1, out_vtx).addArrow(0.2).addLabel(r"\APquark")
	fb1.addParallelArrow(size=0.1, displace=-0.06, sense=-1)
	fb2 = Fermion(out_vtx, out2).addArrow(0.8).addLabel(r"\Pquark")
	glu = Gluon(midpoint(out_vtx, out1), midpoint(out_vtx, out2)).set3D()
	glu.invert().bend(0.5).addLabel("\Pgluon", displace=0.35)
	glu.addParallelArrow(size=0.1, displace=0.2, sense=-1)

	fd.draw("pyfeyn-test1.pdf")

@plot
def alpha_s_at_T(args):
	fig, ax = plt.subplots(nrows=1, ncols=1,
							 figsize=(columnwidth, columnwidth))
	Tc = 0.154
	T = np.linspace(1, 4, 100)*Tc
	for mu, num, c in zip([0.25, 0.5, 1, 2, 4],
		["1/4", "1/2", "1", "2", "4"], [cr,co,cg,cb,'k']):
		ax.plot(T/Tc, alpha_s(0., T, mu), color=c, label=r"${:s}\pi T$".format(num))
	ax.set_xlabel(r'$T/T_c$')
	ax.set_ylabel(r'$\alpha_s(T)$')
	ax.set_ylim(0,1)
	ax.set_xlim(1,4)
	ax.legend()
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.05, 0.04, 0.98, 0.98])

@plot
def tau_f(_):
	fig, axes = plt.subplots(nrows=2, ncols=1, sharex=True,
							 figsize=(columnwidth, 1.5*columnwidth))
	M = 1.3
	T = 0.2
	E = 20.
	def tau_f(sqrts, T, kperp, etak, switch):
		pmax = 0.5*(sqrts-M*M/sqrts)
		xb = kperp*np.exp(np.abs(etak))/sqrts
		x = kperp*np.exp(etak)/sqrts
		k = kperp*np.cosh(etak)
		if k >= pmax:
			return 0.
		else:
			return 2.*k*(1.-xb)/(kperp**2 + (x*M)**2 + switch*(1.-xb)*0.5*mD2(T, 2.))
	tau_f = np.vectorize(tau_f)

	x = np.linspace(0, T*5, 100) # kperp
	y = np.linspace(-8, 8, 300) # etak

	X, Y = np.meshgrid(x, y)
	X = X.T
	Y = Y.T
	tks = [0, 5, 10], [-2,0,2,4]
	titles = r"$m_g^2 = 0$", r"$m_g^2 = m_D^2/2$"
	vcom = (E-T)/(E+T)
	gcom = 1./np.sqrt(1.-vcom**2)
	vhq = np.sqrt(1.-(M/E)**2)
	eta_com = 0.5*np.log((1+vcom)/(1-vcom))
	for s, ax, tk, title in zip([0,1], axes, tks, titles):
		sqrts = np.sqrt(4.*E*T)
		pmax = 0.5*(sqrts-M*M/sqrts)
		Z = np.log(tau_f(sqrts, T, X, Y, s)*T/gcom/(vhq-vcom))
		im = ax.contourf(X/T, Y+eta_com, Z, 10)
		ax.plot(x/T, np.arccosh(pmax/x)+eta_com, 'r--',
				label='Kinetic constrain')
		ax.plot(x/T, -np.arccosh(pmax/x)+eta_com, 'r--')
		ax.annotate(title, xy=(3,6))
		cb = fig.colorbar(im, ax=ax, pad=0.15, ticks=tk)
		cb.ax.set_title(r'$\ln\left(\tau_f T\right)$')
		if s<0.5:
			ax.legend(loc="lower right")
		else:
			ax.set_xlabel(r'$k_\perp / T$')
			ax.annotate(r'$E={:1.1f}$ [GeV]'.format(E)+'\n'\
						+r'$M={:1.1f}$ [GeV]'.format(M)+'\n'\
						+r'$T={:1.1f}$ [GeV]'.format(T),
						xy=(2.5,-4))
		ax.set_ylabel(r'$\eta$')
		ax.set_xticks([0,1,2,3,4,5])
		ax.set_yticks([-4,0,4,8])

	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def BoxRate(quark):
	M = 1.3 if quark == 'charm' else 4.2
	fig, axes = plt.subplots(nrows=2, ncols=3, sharex=True, #sharey=True,
							 figsize=(textwidth, 1.2*columnwidth))

	f = h5py.File('data/BoxRate.h5','r')
	coll = f['coll']
	rad_abs = f['rad-abs']
	T = coll.attrs['T']
	E = coll.attrs['E']
	L = coll.attrs['L']
	dt = L[1] - L[0]
	color = ['b', 'r','g']
	line = ['-', '--', '-.']
	Eindex = [5, 10, 19]
	for iE, eE in enumerate([E[5], E[10], E[19]]):
		axes[0, iE].set_title(r"$E = {:1.1f}$ GeV".format(eE))
		for iT, eT in enumerate(T[:]):
			name = '{}/{}'.format(iT, Eindex[iE])
			Rra = np.sum(rad_abs[name].value[:,2::], axis=1)/dt
			Rc= np.sum(coll[name].value[:,:2], axis=1)/dt
			# charm
			l = r"$T = {:1.1f}$ GeV".format(eT)
			axes[0, iE].plot(L[::2]*eT, (Rc[::2]+Rc[1::2])/2./eT, line[iT], color=color[iT], label=l+', coll')
			axes[1, iE].plot(L[::2]*eT, (Rra[::2]+Rra[1::2])/2./eT, line[iT], color=color[iT], label=l+', rad+abs')
			#axes[1, iE].plot(L*eT*5.026, dEra/L/eT/5.026, 'o'+line[iT], color=color[iT], label=l+', rad+abs')
			axes[0, iE].set_ylim(0,4.5)
			axes[1, iE].set_ylim(0,1.4)
			#axes[1, iE].set_xlim(0,15)
			#axes[2, iE].plot(L, dEr/dEc, line[iT], color=color[iT], label=l+",rad/coll")
			#axes[2, iE].plot(L, dEra/dEc, 'o'+line[iT], color=color[iT], label=l+",(rad+abs)/coll")
			#axes[2, iE].plot(L, np.ones_like(L), 'k-')
			#axes[2, iE].set_ylim(0,3.5)
	f.close()

	axes[0,0].set_ylabel(r"Elastic $R/T$")
	axes[1,0].set_ylabel(r"Inelastic $R/T$ ")
	#axes[2,0].set_ylabel(r"Inelastic / Elastic")
	axes[0,2].legend(framealpha=0., loc="upper right", fontsize=8)
	axes[1,2].legend(framealpha=0., loc="upper left", fontsize=8)
	#axes[2,0].legend(framealpha=0., loc="upper left", fontsize=8)
	axes[1,1].set_xlabel(r"$LT$")
	#for i in [1,2]:
	#	for j in [0,1,2]:
	#		axes[j,i].set_yticks([])
	#		axes[2-i,j].set_xticks([])
	plt.tight_layout(True)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.01, 0.02, 0.99, 0.98])


@plot
def L_Eloss(quark):
	M = 1.3 if quark == 'charm' else 4.2
	fig, axes = plt.subplots(nrows=2, ncols=3, sharex=True, #sharey=True,
							 figsize=(textwidth, 1.2*columnwidth))

	f = h5py.File('data/Eloss.h5','r')
	coll = f['coll']
	rad = f['rad']
	rad_abs = f['rad-abs']
	T = rad.attrs['T']
	E = rad.attrs['E']
	L = rad.attrs['L']
	color = ['b', 'r','g']
	line = ['-', '--', '-.']
	Eindex = [5, 10, 19]
	for iE, eE in enumerate([E[5], E[10], E[19]]):
		axes[0, iE].set_title(r"$E = {:1.1f}$ GeV".format(eE))
		for iT, eT in enumerate(T[:]):
			name = '{}/{}'.format(iT, Eindex[iE])
			dEra = rad_abs[name].value
			dEr = rad[name].value
			dEc = coll[name].value
			# charm
			l = r"$T = {:1.1f}$ GeV".format(eT)
			axes[0, iE].plot(L*eT*5.026, dEc/eE/L/eT/5.026, 'o', color=color[iT], label=l+', coll')
			axes[1, iE].plot(L*eT*5.026, dEra/eE/L/eT/5.026, 'o', color=color[iT], label=l+', rad+abs')
			#axes[1, iE].plot(L*eT*5.026, dEra/L/eT/5.026, 'o'+line[iT], color=color[iT], label=l+', rad+abs')
			axes[0, iE].set_ylim(0,0.05)
			axes[1, iE].set_ylim(0,0.04)
			axes[1, iE].set_xlim(0,15)
			#axes[2, iE].plot(L, dEr/dEc, line[iT], color=color[iT], label=l+",rad/coll")
			#axes[2, iE].plot(L, dEra/dEc, 'o'+line[iT], color=color[iT], label=l+",(rad+abs)/coll")
			#axes[2, iE].plot(L, np.ones_like(L), 'k-')
			#axes[2, iE].set_ylim(0,3.5)
	f.close()

	axes[0,0].set_ylabel(r"Elastic $(\Delta E/E) /(LT)$")
	axes[1,0].set_ylabel(r"Inelastic $(\Delta E/E) /(LT)$ ")
	#axes[2,0].set_ylabel(r"Inelastic / Elastic")
	axes[0,0].legend(framealpha=0., loc="upper left", fontsize=8)
	axes[1,0].legend(framealpha=0., loc="upper left", fontsize=8)
	#axes[2,0].legend(framealpha=0., loc="upper left", fontsize=8)
	axes[1,1].set_xlabel(r"$LT$")
	#for i in [1,2]:
	#	for j in [0,1,2]:
	#		axes[j,i].set_yticks([])
	#		axes[2-i,j].set_xticks([])
	plt.tight_layout(True)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.01, 0.02, 0.99, 0.98])

@plot
def E_Eloss(quark):
	M = 1.3 if quark == 'charm' else 4.2
	fig, axes = plt.subplots(nrows=2, ncols=3, sharex=True, sharey=True,
							 figsize=(textwidth, 1.2*columnwidth))

	f = h5py.File('data/Eloss.h5','r')
	coll = f['coll']
	rad = f['rad']
	rad_abs = f['rad-abs']
	T = rad.attrs['T']
	E = rad.attrs['E']
	L = rad.attrs['L']
	color = ['b', 'r']
	line = ['-', '--']
	index = [10, 30, 49]
	for iL, eL in enumerate([L[10], L[30], L[49]]):
		axes[0, iL].set_title(r"$t = {:1.1f}$ fm/c".format(eL))
		for iT, eT in enumerate(T[::2]):
			dEra = np.array([rad_abs['{}/{}'.format(iT*2, iE)][index[iL]]
							for iE in range(len(E))])
			dEr = np.array([rad['{}/{}'.format(iT*2, iE)][index[iL]]
							for iE in range(len(E))])
			dEc = np.array([coll['{}/{}'.format(iT*2, iE)][index[iL]]
							for iE in range(len(E))])
			print(dEra)
			l = r"$T = {:1.1f}$ GeV".format(eT)
			axes[0, iL].plot(E, dEc/E, line[iT], color=color[iT], label=l+', coll')
			axes[1, iL].plot(E, dEr/E, line[iT], color=color[iT], label=l+', rad')
			axes[1, iL].plot(E, dEra/E, 'o'+line[iT], color=color[iT], label=l+', rad+abs')
			axes[0, iL].set_ylim(-.1, 0.3)
			axes[1, iL].set_ylim(-.15, 0.35)
			#axes[2, iL].plot(E, dEr/(dEc+dEr), line[iT], color=color[iT], label=l+', rad/coll')
			#axes[2, iL].plot(E, dEra/(dEc+dEra), 'o'+line[iT], color=color[iT], label=l+', (rad+abs)/coll')
			#axes[2, iL].plot(E, np.ones_like(E), 'k-')
			#axes[2, iL].set_ylim(0,1)
			for i in range(2):
				axes[i, iL].semilogx()
	f.close()

	axes[0,0].set_ylabel(r"Elastic $\Delta E / E$")
	axes[1,0].set_ylabel(r"Inelastic $\Delta E / E$ ")
	axes[0,0].legend(framealpha=0., loc="upper left", fontsize=8)
	axes[1,0].legend(framealpha=0., loc="upper left", fontsize=8)
	axes[1,1].set_xlabel(r"$E$ [GeV]")
	#for i in range(3):
	#	axes[0,i].set_xticks([])
	#for i in range(2):
	#	for j in range(1,3):
	#		axes[i,j].set_yticks([])

	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.01, 0.02, 0.99, 0.98])

@plot
def thermalization(quark):
	mass = 1.3 if quark == 'charm' else 4.2
	def norm_boltzmann(T):
		E = np.linspace(1, 10, 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return np.sum(dfdE)*(E[1]-E[0])
	def thermal_dfdE(T):
		E = np.linspace(1, 10., 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return E, dfdE/norm_boltzmann(T)
	def S_diff(E, T):
		values = np.log(norm_boltzmann(T)) + E/T
		return np.mean(values), np.std(values)/np.sqrt(len(E)*1.)
	def S_same(T):
		E = np.linspace(1, 10., 1000)*mass
		norm = norm_boltzmann(T)
		y = (E/T + np.log(norm))*np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi/norm
		return np.sum(y)*(E[1]-E[0])
	def get_xy(ds):
		E0 = 10.
		Temp = 0.4
		dt = 1.0
		S0 = S_same(Temp)
		t = np.linspace(0,len(ds)-1,len(ds))
		S = []
		for i in range(len(t)):
			E = ds['{:d}'.format(i)].value[0]
			S.append(S_diff(E, Temp))
		S = np.array(S).T
		return t, S[0]-S0, S[1]

	fig, axes1 = plt.subplots(nrows=1, ncols=1,
							 figsize=(columnwidth, columnwidth))
	f = h5py.File("./data/thermalization.hdf5", 'r')
	left, bottom = 0.5, 0.35
	width, height = 0.4, 0.3
	axes2 = fig.add_axes([left, bottom, width, height])
	for name, fmt, c, label in \
		zip(['coll', 'coll+rad', 'coll+rad+abs'],
			[':', '--', '-'], [cr, cg, cb],
			['Elastic', 'Elastic + rad.',
			'Elastic + rad. + abs.']):
		t, S, dS = get_xy(f[name])
		for ia, (ax, ylim) in enumerate(zip([axes1, axes2], [[-2,30], [-1,2]])):
			ax.plot(t, S, fmt, color=c, label=label)
			ax.fill_between(t, S-dS*2, S+dS*2, color=c, alpha=0.4)
			ax.set_ylim(*ylim)
			ax.plot(t, np.zeros_like(t),'k:')
			if ia==1:
				ax.set_xticks([0,100])
				ax.set_yticks([-1,0,1,2])
			else:
				ax.legend()
				ax.set_title(r"$E_0 = 10.0$ [GeV], $T = 0.4$ [GeV]")
				ax.set_ylabel(r'$\Delta S$')
				ax.set_xlabel(r'$t$ [fm/c]')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def hybrid_thermalization(quark):
	mass = 1.3 if quark == 'charm' else 4.2
	def norm_boltzmann(T):
		E = np.linspace(1, 10, 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return np.sum(dfdE)*(E[1]-E[0])
	def thermal_dfdE(T):
		E = np.linspace(1, 10., 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return E, dfdE/norm_boltzmann(T)
	def S_diff(E, T):
		values = np.log(norm_boltzmann(T)) + E/T
		return np.mean(values), np.std(values)/np.sqrt(len(E)*1.)
	def S_same(T):
		E = np.linspace(1, 10., 1000)*mass
		norm = norm_boltzmann(T)
		y = (E/T + np.log(norm))*np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi/norm
		return np.sum(y)*(E[1]-E[0])
	def get_xy(ds):
		E0 = ds.attrs['E']
		Temp = ds.attrs['T']
		dt = ds.attrs['dt']
		S0 = S_same(Temp)
		tarray = (np.array(range(len(ds.value)))+1.)*dt
		sarray = np.array([S_diff(si, Temp) \
							for si in ds.value[::5,:,0]]).T
		return tarray[::5], sarray[0]-S0, sarray[1]

	fig, axes = plt.subplots(nrows=2, ncols=1,
							 figsize=(columnwidth, columnwidth))
	f = h5py.File("hybrid_thermalization.hdf5", 'r')

	for name, fmt, c, label in \
		zip(['T300E10-lgv', 'T300E10-elastic', 'T300E10-lgv-B-elastic'],
			[':', '--', '-', '-.'], [cr, cg, cb, co],
			['Diffusion', 'Diff + elastic', 'Diff-B + elastic']):
		t, S, dS = get_xy(f[name])
		for ia, (ax, ylim) in enumerate(zip(axes, [[-2,30], [-1,2]])):
			ax.plot(t, S, fmt, color=c, label=label)
			ax.fill_between(t, S-dS*2, S+dS*2, color=c, alpha=0.4)
			ax.set_ylim(*ylim)
			ax.plot(t, np.zeros_like(t),'k:')
			if ia==1:
				ax.set_xlabel(r'$t$ [fm/c]')
				ax.annotate(r"$E_0 = 10.0$ [GeV]" + "\n"	\
							+"$T = 0.3$ [GeV]", xy=(80,-0.8))
			else:
				ax.legend(loc='upper right')
			ax.set_ylabel(r'$\Delta S$')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])


@plot
def static_process(quark):
	mass = 1.3 if quark == 'charm' else 4.2
	def norm_boltzmann(T):
		E = np.linspace(1, 4, 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return np.sum(dfdE)*(E[1]-E[0])
	def thermal_dfdE(T):
		E = np.linspace(1, 4., 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return E, dfdE/norm_boltzmann(T)

	fig, axes = plt.subplots(nrows=3, ncols=1, sharex=True, sharey=True,
							 figsize=(columnwidth, columnwidth*1.3))
	f = h5py.File(quark+"-data/thermalization.hdf5", 'r')
	labels = ['Elastic', 'Elastic + rad.', 'Elastic + rad. + abs.']
	labels2 = [r'$t = 1$ [fm/c]', r'$t = 10$ [fm/c]', \
				r'$t = 50$ [fm/c]', r'$t = 150$ [fm/c]']
	names = ['T300E10-22', 'T300E10-22-23', 'T300E10-22-23-32']
	colors = [cr, co, cg, cb]
	times = [1, 9, 99, 299]
	for i in range(3):
		ds = f[names[i]]
		E0 = ds.attrs['E']
		Temp = ds.attrs['T']
		dt = ds.attrs['dt']
		ax = axes[i]
		ax.plot([E0, E0], [0.0, 1.5], 'k-', label="Initial" if i==0 else '')
		ax.plot(*thermal_dfdE(Temp), 'k--', label="Boltzmann, $T = 0.3$ [GeV]"\
		 													if i==0 else '')
		ax.set_title(labels[i])
		for j in range(4):
			E = ds.value[times[j],:,0]
			ax.hist(E, range=[1.3, 11], bins=100, normed=True,
					histtype='step', color=colors[j],
					label=labels2[j] if i==2 else '')
		ax.legend(fontsize=textiny)
		ax.set_xlim(mass-0.1,11)
		ax.set_ylim(0,2)
		if i==2:
			ax.set_xlabel(r'$E$ [GeV]')
		if i==1:
			ax.set_ylabel(r'$df/dE$ [GeV${}^{-1}$]')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def static_hybrid_process(quark):
	mass = 1.3 if quark == 'charm' else 4.2
	def norm_boltzmann(T):
		E = np.linspace(1, 4, 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return np.sum(dfdE)*(E[1]-E[0])
	def thermal_dfdE(T):
		E = np.linspace(1, 4., 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return E, dfdE/norm_boltzmann(T)

	fig, axes = plt.subplots(nrows=2, ncols=1, sharex=True, sharey=True,
							 figsize=(columnwidth, columnwidth))
	f = h5py.File("hybrid_thermalization.hdf5", 'r')
	labels = ['Diffusion-A', 'Diffusion-B', 'Diff + el', 'Diff + el + inelastic']
	labels2 = [r'$t = 1$ [fm/c]', r'$t = 5$ [fm/c]', \
				r'$t = 20$ [fm/c]', r'$t = 100$ [fm/c]']
	names = ['T300E10-lgv', 'T300E10-lgv-B'] #, 'T300E10-22', 'T300E10-lgv-elastic', 'T300E10-lgv-elastic-23-32']
	colors = [cr, co, cg, cb]
	times = [1, 9, 39, 199]
	for i, ax in enumerate(axes):
		ds = f[names[i]]
		E0 = ds.attrs['E']
		Temp = ds.attrs['T']
		dt = ds.attrs['dt']
		ax.plot([E0, E0], [0.0, 10], 'k-', label="Initial" if i==0 else '')
		ax.plot(*thermal_dfdE(Temp), 'k--', label="Boltzmann, $T = 0.3$ [GeV]"\
		 													if i==0 else '')
		ax.set_title(labels[i])
		for j in range(4):
			E = ds.value[times[j],:,0]
			ax.hist(E, range=[1.3, 11], bins=100, normed=True,
					histtype='step', color=colors[j],
					label=labels2[j] if i==1 else '')
		ax.legend(fontsize=textiny)
		ax.set_xlim(mass-0.1,11)
		ax.set_ylim(0,2)
		if i==1:
			ax.set_xlabel(r'$E$ [GeV]')
		if i==1:
			ax.set_ylabel(r'$df/dE$ [GeV${}^{-1}$]')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def avg_alphas(quark):
	def get_a(muset):
		name = 'Rates-tab'
		f = h5py.File(quark+'-data/avg-alpha_s/RQq2Qq-{}.hdf5'.format(muset), 'r')
		R0 = f[name].value
		f = h5py.File(quark+'-data/avg-alpha_s/RQg2Qg-{}.hdf5'.format(muset), 'r')
		R0 += f[name].value
		f = h5py.File(quark+'-data/avg-alpha_s/aRQq2Qq-{}.hdf5'.format(muset), 'r')
		aR0 = f[name].value
		f = h5py.File(quark+'-data/avg-alpha_s/aRQg2Qg-{}.hdf5'.format(muset), 'r')
		aR0 += f[name].value

		NT = f[name].attrs['N_T']
		TH = f[name].attrs['T_high']
		TL = f[name].attrs['T_low']
		NE = f[name].attrs['N_E1']
		EH = f[name].attrs['E1_high']
		EL = f[name].attrs['E1_low']
		T = np.linspace(TL, TH, NT)
		E = np.linspace(EL, EH, NE)
		mE, mT = np.meshgrid(E, T)
		mE = mE.T
		mT = mT.T
		return mE, mT, aR0/R0

	from matplotlib import cm
	from mpl_toolkits.mplot3d import Axes3D
	fig = plt.figure(figsize=(columnwidth, columnwidth))
	ax = fig.add_subplot(1, 1, 1, projection='3d')

	for muset, cmm in zip(['1piT', '2piT', '4piT'], ['Red', 'Green', 'Blue']):
		E, T, data = get_a(muset)
		ax.plot_surface(np.log10(E), T, data, rstride=1, cstride=1,
						color=cmm, alpha=0.4,
                        linewidth=0, antialiased=False)
	ax.set_xlabel(r'$E$ [GeV]')
	ax.set_ylabel(r'$T$ [GeV]')
	ax.set_zlim(0, 1.0)
	ax.set_zlabel(r'$\langle\alpha_s(\mu^2)\rangle$')
	ax.set_xticks([np.log10(1.3),np.log10(10),np.log10(100)])
	ax.set_yticks([0.2, 0.4, 0.6])
	ax.set_xticklabels(['1.3', '10', '100'])
	ax.view_init(5, 150)
	ax.text(1, 0.8, 0.33, r"$n=1$", (-1,0 ,0), fontsize=8)
	ax.text(1, 0.8, 0.225, r"$n=2$", (-1,0,0), fontsize=8)
	ax.text(1, 0.8, 0.12, r"$n=4$", (-1, 0,0), fontsize=8)
	fig.subplots_adjust(left=0.05, right=0.85, top=0.9)
	ax.set_title(r'Rate averaged $\alpha_s(\mu)$, screened propagator' + '\n'\
		+ r'$\mu=\mathrm{max}\{Q, n\pi T\}$')
@plot
def Rscale(quark):
	def get_R(muset):
		name = 'Rates-tab'
		f = h5py.File(quark+'-data/avg-alpha_s/RQq2Qq-{}.hdf5'.format(muset), 'r')
		R = f[name].value
		f = h5py.File(quark+'-data/avg-alpha_s/RQg2Qg-{}.hdf5'.format(muset), 'r')
		R += f[name].value
		NT = f[name].attrs['N_T']
		TH = f[name].attrs['T_high']
		TL = f[name].attrs['T_low']
		NE = f[name].attrs['N_E1']
		EH = f[name].attrs['E1_high']
		EL = f[name].attrs['E1_low']
		T = np.linspace(TL, TH, NT)
		E = np.linspace(EL, EH, NE)
		mE, mT = np.meshgrid(E, T)
		mE = mE.T
		mT = mT.T
		return mE, mT, R

	from matplotlib import cm
	from mpl_toolkits.mplot3d import Axes3D
	fig = plt.figure(figsize=(columnwidth, columnwidth))
	ax = fig.add_subplot(1, 1, 1, projection='3d')

	E, T, R1 = get_R('1piT')
	E, T, R2 = get_R('2piT')
	E, T, R4 = get_R('4piT')
	ax.plot_surface(np.log10(E), T, R1/R2, rstride=1, cstride=1,
							color='red', alpha=0.5,
	                       linewidth=0, antialiased=False)
	ax.plot_surface(np.log10(E), T, R2/R2, rstride=1, cstride=1,
							color='green', alpha=0.5,
	                       linewidth=0, antialiased=False)
	ax.plot_surface(np.log10(E), T, R4/R2, rstride=1, cstride=1,
							color='blue', alpha=0.5,
	                       linewidth=0, antialiased=False)
	ax.set_xlabel(r'$E$ [GeV]')
	ax.set_ylabel(r'$T$ [GeV]')

	ax.set_zlim(0, 3.0)
	ax.set_zlabel(r'$R(n \pi T)/R(2\pi T)$')
	ax.set_xticks([np.log10(1.3),np.log10(10),np.log10(100)])
	ax.set_yticks([0.2, 0.4, 0.6])
	ax.set_xticklabels(['1.3', '10', '100'])
	ax.view_init(5, 150)
	ax.text(1., 0.8, 1.4, r"$n=1$", (1,0,0), fontsize=8)
	ax.text(1., 0.8, 1.0, r"$n=2$", (1,0,0), fontsize=8)
	ax.text(1., 0.8, 0.6, r"$n=4$", (1,0,0), fontsize=8)
	fig.subplots_adjust(left=0.02, right=0.85, top=0.92, bottom=0.02)
	ax.set_title('Change of scattering rates varying scales' + '\n'\
		+ r'$\alpha_s (\mu = \mathrm{max}\{Q, n\pi T\} )$')

@plot
def Box_Raa(quark):
	def dN_dp_init(quark, pabs):

		Lambda = 2.1 if quark == 'charm' else 7.5 # [GeV]
		power = 3.9 if quark == 'charm' else 4.9
		return pabs/(pabs**2+Lambda**2)**power
	fig, axes = plt.subplots(nrows=1, ncols=1, sharex=True, sharey=True,
							 figsize=(columnwidth, columnwidth))
	Raa = {'c':{1: np.loadtxt("./data/BoxRaa-mu1-charm.dat").T,
				2: np.loadtxt("./data/BoxRaa-mu2-charm.dat").T},
		   'b':{1: np.loadtxt("./data/BoxRaa-mu1-bottom.dat").T,
				2: np.loadtxt("./data/BoxRaa-mu2-bottom.dat").T}}
	ax = axes
	for s in ['c', 'b']:
		x, y1 = Raa[s][1]
		x, y2 = Raa[s][2]
		color = 'red' if s=='c' else 'blue'
		ax.fill_between(x, y1, y2,
						facecolor='white',
						edgecolor=color,
						hatch='///',
						alpha=0.5,
						label="charm" if s=='c' else "bottom")

		ax.plot(x, y1,'-', color=color)
		ax.plot(x, y2,'--', color=color)

		ax.set_ylim(0, 1.2)
		ax.legend(fontsize=10, loc='upper right')
		if s=='c':
			ax.set_ylabel(r'$R_{AA}$, quark', fontsize=10)
			ax.annotate(r'$\frac{dN}{dp_T^2}\propto \frac{1}{\left(p_T^2 + a^2\right)^{b}}$'+'\n'+'charm: $a = 2.1, b = 3.9$\n'+'bottom: $a = 7.5, b = 4.9$',
			 			xy=(30, 0.15), fontsize=10)
			ax.annotate(r"$\mu = 1\pi T$", xy=(80,0.45), fontsize=10)
			ax.annotate(r"$\mu = 2\pi T$", xy=(80,0.75), fontsize=10)

		ax.set_xlabel(r'$p_T$ [GeV]', fontsize=10)

	# plots
	plt.subplots_adjust(wspace=0.)
	plt.suptitle(r'$T=0.4$' +' GeV' + r', $\Delta t=4$' +' fm/c', fontsize=10)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.95, 0.95])

@plot
def Raa_32(quark):
	def dN_dp_init(quark, pabs):
		# https://arxiv.org/pdf/1205.2396.pdf
		Lambda = 2.1 if quark == 'charm' else 7.5 # [GeV]
		power = 3.9 if quark == 'charm' else 4.9#4.9
		return pabs/(pabs**2+Lambda**2)**power

	def plot_1Raa(quark, ax, type, c, l, label):
		mass = 1.3 if quark == 'charm' else 4.2
		f = h5py.File(quark+"-data/{}-Box-Raa.hdf5".format(quark), 'r')
		y = []
		for pre in ['2piT-']:
			p0abs, p1abs = f[pre+type].value.T
			W = dN_dp_init(quark, p0abs)
			H00, bins = np.histogram(p0abs, 50, weights=W, normed=True, range=[0,105])
			H1, bins = np.histogram(p1abs, 50, weights=W, normed=True, range=[0,105])
			x = (bins[1:] + bins[:-1])/2.
			norm = dN_dp_init(quark, np.linspace(0,100,2000)).sum()*100./2000.
			H0 = np.array([dN_dp_init(quark,
					np.linspace(bins[i], bins[i+1], 20)).mean()/norm
							for i in range(len(x))])
			y.append(H1/H00)
		"""
		ax.fill_between(x, y[0], y[2],
						facecolor='white' if '23' not in type else c,
						edgecolor=c,
						hatch='///' if '23' not in type else '',
						alpha=0.5,
						label=label if quark == 'bottom' else '')
		"""
		ax.plot(x, y[0],l, color=c, label=label)
		ax.set_ylim(0, 1.2)
		ax.legend(fontsize=12, loc='upper right')
		if quark=='charm':
			ax.set_ylabel(r'$R_{AA}$, quark', fontsize=15)
			ax.annotate('Charm\n'+ r'$\frac{dN}{dp_T^2}\propto \frac{1}{\left(p_T^2 + 2.1^2\right)^{3.9}}$',
			 			xy=(40, 0.15), fontsize=15)
		else:
			ax.annotate('Bottom\n'+ r'$\frac{dN}{dp_T^2}\propto \frac{1}{\left(p_T^2 + 7.5^2\right)^{4.9}}$',
			 			xy=(40, 0.15), fontsize=15)
		ax.set_xlabel(r'$p_T$ [GeV]', fontsize=15)

	# plots
	fig, axes = plt.subplots(nrows=1, ncols=1, sharex=True, sharey=True,
							 figsize=(columnwidth*1.3, columnwidth*1.3))
	for quark, ax in zip(['charm'], [axes]):
		plot_1Raa(quark, ax,'T3004fm-22', cr, '--',label='Elastic')
		plot_1Raa(quark, ax,'T3004fm-22-23', cb, '-', label='Elastic+23')
		plot_1Raa(quark, ax,'T3004fm-22-23-32', cb, ':', label='Elastic+23+32')
	plt.subplots_adjust(wspace=0.)
	plt.suptitle(r'$T=300$' +'[GeV]' + r', $\Delta t=4$' +'[fm/c]', fontsize=15)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.95, 0.95])


@plot
def qhat(dummy):
	def plot(ax, quark, a, b, c):
		M = 1.3 if quark == 'charm' else 4.2
		Lambda = 0.2
		T = np.linspace(0.1, 0.7, 50)
		E = np.linspace(1, 100, 50)*M
		E, T = np.meshgrid(E, T)
		E = E.T
		T = T.T
		qhatT3 = a*(1/T)**2 + b/E/T
		D2piT = 8.*np.pi/qhatT3
		ax.plot_surface(np.log10(np.sqrt(E**2-M**2)), T, D2piT, rstride=1, cstride=1,
								color=c, alpha=0.5,
		                        linewidth=0, antialiased=False)
	from matplotlib import cm
	from mpl_toolkits.mplot3d import Axes3D
	fig = plt.figure(figsize=(columnwidth, columnwidth))
	ax = fig.add_subplot(1, 1, 1, projection='3d')
	plot(ax, 'charm', .0, 1.0, 'Blue')
	plot(ax, 'bottom', .0, 1.0, 'Red')
	ax.set_xlabel(r'$p$ [GeV]')
	ax.set_ylabel(r'$T$ [GeV]')
	ax.set_zlabel(r'$\hat{q}/T^3$')
	#ax.set_zlim(0, 15)
	ax.set_xticks([np.log10(1),np.log10(10),np.log10(100)])
	ax.set_yticks([0.2, 0.4, 0.6])
	ax.set_xticklabels(['1', '10', '100'])
	ax.view_init(5, -130)
	plt.show()
	fig.subplots_adjust(left=0.1, right=0.95, top=0.9)

def main(quark):
	parser = argparse.ArgumentParser()
	parser.add_argument('plots', nargs='*')
	args = parser.parse_args()

	if args.plots:
		for i in args.plots:
			if i.endswith('.pdf'):
				name = os.path.basename(i)
				plot_path = os.path.dirname(i)
				i = name[:-4]
			if i in plot_functions:
				plot_functions[i](quark)
				subprocess.call("mv {} {}".format(name, plot_path), shell=True)
			else:
				print('unknown plot:', i)
	else:
		for f in plot_functions.values():
			f(quark)


if __name__ == "__main__":
	main('charm')
