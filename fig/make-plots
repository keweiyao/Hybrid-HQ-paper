#!/usr/bin/env python3

import matplotlib.pyplot as plt
import numpy as np
import argparse
import colorsys
import h5py
import husl
import glob
import os
import subprocess
import pickle
from itertools import chain
from scipy import interpolate
from scipy.optimize import brentq
from matplotlib import ticker
from matplotlib.colors import LinearSegmentedColormap
from matplotlib import patches
from matplotlib import gridspec

aspect = 1/1.618
resolution = 72.27
columnwidth = 246/resolution
textwidth = 510/resolution
textiny, texsmall, texnormal = 8.0, 9.25, 10.0
cm1, cm2 = plt.cm.Blues(.8), plt.cm.Reds(.8)
cb,co,cg,cr = plt.cm.Blues(.6), \
	plt.cm.Oranges(.6), plt.cm.Greens(.6), plt.cm.Reds(.6)
offblack = '#262626'
gray = '0.8'

plt.rcdefaults()
plt.rcParams.update({
	'font.family': 'sans-serif',
	'font.serif': ['CMU Serif'],
	'font.size': texsmall,
	'legend.fontsize': texsmall,
	'axes.labelsize': texsmall,
	'axes.titlesize': texsmall,
	'xtick.labelsize': textiny,
	'ytick.labelsize': textiny,
	'font.weight': 400,
	'axes.labelweight': 400,
	'axes.titleweight': 400,
	'lines.linewidth': .9,
	'lines.markersize': 3,
	'lines.markeredgewidth': .1,
	'patch.linewidth': .9,
	'axes.linewidth': .5,
	'xtick.major.width': .5,
	'ytick.major.width': .5,
	'xtick.minor.width': .5,
	'ytick.minor.width': .5,
	'xtick.major.size': 2,
	'ytick.major.size': 2,
	'xtick.minor.size': 1.3,
	'ytick.minor.size': 1.3,
	'xtick.major.pad': 1.8,
	'ytick.major.pad': 1.8,
	'text.color': 'black',
	'axes.edgecolor': 'black',
	'axes.labelcolor': 'black',
	'xtick.color': 'black',
	'ytick.color': 'black',
	'legend.numpoints': 1,
	'legend.scatterpoints': 1,
	'legend.frameon': False,
	'image.interpolation': 'none',
	'pdf.fonttype': 42,
})


plot_functions = {}

def plot(f):
	def wrapper(*args, **kwargs):
		print(f.__name__)
		f(*args, **kwargs)
		plt.savefig('{}.pdf'.format(f.__name__))
		plt.close()

	plot_functions[f.__name__] = wrapper

	return wrapper


def finish(despine=True, remove_ticks=False, pad=0.1, h_pad=None, w_pad=None,
		   rect=[0, 0, 1, 1]):
	fig = plt.gcf()

	for ax in fig.axes:
		if despine:
			for spine in 'top', 'right':
				ax.spines[spine].set_visible(False)

		if remove_ticks:
			for ax_name in 'xaxis', 'yaxis':
				getattr(ax, ax_name).set_ticks_position('none')
		else:
			ax.xaxis.set_ticks_position('bottom')
			ax.yaxis.set_ticks_position('left')

	fig.tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)


def set_loc(ax, xy=None, nbins=5, steps=[1, 2, 3, 4, 5, 10],
			prune=None, minor=0):
	if xy == 'x':
		axes = ax.xaxis,
	elif xy == 'y':
		axes = ax.yaxis,
	else:
		axes = ax.xaxis, ax.yaxis

	for axis in axes:
		axis.set_major_locator(
			ticker.MaxNLocator(nbins=nbins, steps=steps, prune=prune)
		)
		if minor:
			axis.set_minor_locator(ticker.AutoMinorLocator(minor))


def desaturate(color, fraction=0.5):
	h, l, s = colorsys.rgb_to_hls(*color[:3])
	return colorsys.hls_to_rgb(h, l, fraction*s)


def recolor(color, f1=0.7, f2=0.7):
	h, l, s = colorsys.rgb_to_hls(*color[:3])
	return colorsys.hls_to_rgb(h, f1*l, f2*s)


def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):
	new_cmap = LinearSegmentedColormap.from_list(
		'trunc({n},{a:.2f},{b:.2f})'.format(n=cmap.name, a=minval, b=maxval),
		cmap(np.linspace(minval, maxval, n)))
	return new_cmap


TRENTO_LABEL = r'T\raisebox{-.5ex}{R}ENTo'



def alpha_s(Q2, T, mu):
	Nc, Nf = 3., 3.
	pf_g = 4.*np.pi/3.*(Nc+Nf/2.)
	alpha0 = 4.*np.pi/(11. - 2./3.*Nf)
	Lambda2 = 0.2**2
	scale2 = (mu*np.pi*T)**2
	if Q2 < 0:
		result = alpha0/np.log(np.max([-Q2, scale2])/Lambda2)
		if result > alpha0 or result < 0.:
			return alpha0
	else:
		return alpha0*(0.5 - np.arctan(np.log(np.max([Q2, scale2])/Lambda2)/np.pi)/np.pi)
alpha_s = np.vectorize(alpha_s)

def mD2(T, mu):
	return alpha_s(0., T, mu)*6.*np.pi*T*T
mD2 = np.vectorize(mD2)

@plot
def alpha_s_at_T(args):
	fig, ax = plt.subplots(nrows=1, ncols=1,
							 figsize=(columnwidth, columnwidth))
	Tc = 0.154
	T = np.linspace(1, 4, 100)*Tc
	for mu, num, c in zip([0.25, 0.5, 1, 2, 4], 
		["1/4", "1/2", "1", "2", "4"], [cr,co,cg,cb,'k']):
		ax.plot(T/Tc, alpha_s(0., T, mu), color=c, label=r"${:s}\pi T$".format(num))
	ax.set_xlabel(r'$T/T_c$')
	ax.set_ylabel(r'$\alpha_s(T)$')
	ax.set_ylim(0,1)
	ax.set_xlim(1,4)
	ax.legend()
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.05, 0.04, 0.98, 0.98])

@plot
def tau_f(_):
	fig, axes = plt.subplots(nrows=2, ncols=1, sharex=True,
							 figsize=(columnwidth, 1.5*columnwidth))
	M = 1.3
	T = 0.2
	E = 20.
	def tau_f(sqrts, T, kperp, etak, switch):
		pmax = 0.5*(sqrts-M*M/sqrts)
		xb = kperp*np.exp(np.abs(etak))/sqrts
		x = kperp*np.exp(etak)/sqrts
		k = kperp*np.cosh(etak)
		if k >= pmax:
			return 0.
		else:
			return 2.*k*(1.-xb)/(kperp**2 + (x*M)**2 + switch*(1.-xb)*0.5*mD2(T, 2.))
	tau_f = np.vectorize(tau_f)

	x = np.linspace(0, T*5, 100) # kperp
	y = np.linspace(-8, 8, 300) # etak

	X, Y = np.meshgrid(x, y)
	X = X.T
	Y = Y.T
	tks = [0, 5, 10], [-2,0,2,4]
	titles = r"$m_g^2 = 0$", r"$m_g^2 = m_D^2/2$"
	vcom = (E-T)/(E+T)
	gcom = 1./np.sqrt(1.-vcom**2)
	vhq = np.sqrt(1.-(M/E)**2)
	eta_com = 0.5*np.log((1+vcom)/(1-vcom))
	for s, ax, tk, title in zip([0,1], axes, tks, titles):
		sqrts = np.sqrt(4.*E*T)
		pmax = 0.5*(sqrts-M*M/sqrts)
		Z = np.log(tau_f(sqrts, T, X, Y, s)*T/gcom/(vhq-vcom))
		im = ax.contourf(X/T, Y+eta_com, Z, 10)
		ax.plot(x/T, np.arccosh(pmax/x)+eta_com, 'r--',
				label='Kinetic constrain')
		ax.plot(x/T, -np.arccosh(pmax/x)+eta_com, 'r--')
		ax.annotate(title, xy=(3,6))
		cb = fig.colorbar(im, ax=ax, pad=0.15, ticks=tk)
		cb.ax.set_title(r'$\ln\left(\tau_f T\right)$')
		if s<0.5:
			ax.legend(loc="lower right")
		else:
			ax.set_xlabel(r'$k_\perp / T$')
			ax.annotate(r'$E={:1.1f}$ [GeV]'.format(E)+'\n'\
						+r'$M={:1.1f}$ [GeV]'.format(M)+'\n'\
						+r'$T={:1.1f}$ [GeV]'.format(T),
						xy=(2.5,-4))
		ax.set_ylabel(r'$\eta$')
		ax.set_xticks([0,1,2,3,4,5])
		ax.set_yticks([-4,0,4,8])
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def L_Eloss(quark):
	M = 1.3 if quark == 'charm' else 4.2
	fig, axes = plt.subplots(nrows=3, ncols=3, sharex=True, #sharey=True,
							 figsize=(textwidth, 1.3*columnwidth))

	f = h5py.File('data/Eloss.h5','r')
	rad = f['rad']
	coll = f['coll']
	T = rad.attrs['T']
	E = rad.attrs['E']
	L = rad.attrs['L']
	
	dL = L[1]-L[0]
	L = L+dL

	color = ['r', 'g']
	line = ['-', '--']
	for iE, eE in enumerate([E[1], E[9], E[19]]):
		axes[0, iE].set_title(r"$E = {:1.1f}$ GeV".format(eE))
		for iT, eT in enumerate(T[::2]):
			name = '{}/{}'.format(iT*2, 1+iE*9)
			dEr = rad[name].value
			dEc = coll[name].value
			# charm
			l = r"$T = {:1.1f}$ GeV".format(eT)
			axes[0, iE].plot(L, dEc/eE, line[iT], color=color[iT], label=l)
			axes[1, iE].plot(L, dEr/eE, line[iT], color=color[iT], label=l)
			axes[0, iE].set_ylim(0,0.22)
			axes[1, iE].set_ylim(0,0.22)
			axes[2, iE].plot(L, dEr/dEc, line[iT], color=color[iT], label=l)
			axes[2, iE].plot(L, np.ones_like(L), 'k-')
			axes[2, iE].set_ylim(0,3)
	f.close()

	axes[0,0].set_ylabel(r"Coll. $\Delta E / E$")
	axes[1,0].set_ylabel(r"Rad. $\Delta E / E$ ")
	axes[2,0].set_ylabel(r"Rad. / Coll.")
	axes[1,0].legend(framealpha=0., loc="upper left", fontsize=9)
	axes[2,1].set_xlabel(r"$t$ [fm/c]")

	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.01, 0.02, 0.99, 0.98])

@plot
def E_Eloss(quark):
	M = 1.3 if quark == 'charm' else 4.2
	fig, axes = plt.subplots(nrows=3, ncols=3, sharex=True, #sharey=True,
							 figsize=(textwidth, 1.3*columnwidth))

	f = h5py.File('data/Eloss.h5','r')
	rad = f['rad']
	coll = f['coll']
	T = rad.attrs['T']
	E = rad.attrs['E']
	L = rad.attrs['L']
	
	dL = L[1]-L[0]
	L = L+dL

	color = ['r', 'g']
	line = ['-', '--']
	index = [40, 60, 80]
	for iL, eL in enumerate([L[40], L[60], L[80]]):
		axes[0, iL].set_title(r"$t = {:1.1f}$ fm/c".format(eL))
		for iT, eT in enumerate(T[::2]):
			dEr = np.array([rad['{}/{}'.format(iT*2, iE)][index[iL]] 
							for iE in range(len(E))])
			dEc = np.array([coll['{}/{}'.format(iT*2, iE)][index[iL]] 
							for iE in range(len(E))])
			l = r"$T = {:1.1f}$ GeV".format(eT)
			axes[0, iL].plot(E, dEc/E, line[iT], color=color[iT], label=l)
			axes[1, iL].plot(E, dEr/E, line[iT], color=color[iT], label=l)
			axes[0, iL].set_ylim(0,0.22)
			axes[1, iL].set_ylim(0,0.22)
			axes[2, iL].plot(E, dEr/dEc, line[iT], color=color[iT], label=l)
			axes[2, iL].plot(E, np.ones_like(E), 'k-')
			axes[2, iL].set_ylim(0,3)
	f.close()

	axes[0,0].set_ylabel(r"Coll. $\Delta E / E$")
	axes[1,0].set_ylabel(r"Rad. $\Delta E / E$ ")
	axes[2,0].set_ylabel(r"Rad. / Coll.")
	
	axes[1,0].legend(framealpha=0., loc="upper left", fontsize=9)
	axes[2,1].set_xlabel(r"$E$ [GeV]")

	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.01, 0.02, 0.99, 0.98])

@plot
def X22_PS():
	M = 1.3
	def get_t(ds):
		T = ds.attrs['T']
		sqrts = ds.attrs['sqrts']
		pmax = sqrts/2.*(1-M*M/sqrts**2)
		p0 = np.array([pmax, 0, 0, -pmax])
		dp = np.array([p0-pi for pi in ds['p4'].value])
		return T, sqrts, dp[:,0]**2-np.sum(dp[:,1:]**2, axis=1)

	f = h5py.File('data/x-ps.hdf5', 'r')
	fig, axes = plt.subplots(nrows=1, ncols=2, sharex=True, sharey=True,
							 figsize=(columnwidth, 0.6*columnwidth))
	for ia, (ax, group) in enumerate(zip(axes, [['elastic-ps-1','elastic-ps-3'],
								['elastic-ps-2','elastic-ps-4']])):
		for name, c in zip(group, [co, cb]):
			T, sqrts, t = get_t(f[name])
			ax.hist(-t/T/T, bins=100, range = [0,10],
					color=c, histtype='step', normed=True,
					label=r"$\sqrt{s} = $"+"${:1.1f}$ [GeV]".format(sqrts))
			ax.set_title("$T = {:1.1f}$ [GeV]".format(T))
			ax.set_xlim(0,10)
			ax.set_xlabel("$-t/T^2$")
			if ia == 0:
				ax.set_ylabel("$-T^2 d\sigma/dt/\sigma$")
			else:
				ax.legend(fontsize=textiny*0.8)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def X23_PS():
	M = 1.3
	def projector(p):
		norm2 = (p**2).sum()
		return np.diag([1,1,1]) - np.outer(p,p)/norm2

	def find_level(H, percentage):
		tot = np.sum(H)
		minH, maxH = np.min(H), np.max(H)
		def percentile_above_level(level):
			return np.sum(H[H>level])/tot - percentage
		return brentq(percentile_above_level, minH, maxH), maxH

	def corner(X1, X2, axes, c1, c2, cmap, ranges):
		name = [r'$\ln(q_{\perp}/T)$', r'$\ln(k_{\perp}/T)$',
				r'$\eta_k$', r'$\phi_{4,k}$']
		ndims, xsamples = X1.shape
		for i in range(ndims):
			for j in range(ndims):
				ax = axes[i,j]
				if i==j:
					ax.hist(X1[i], bins=50, normed=True, range=ranges[i],
							histtype='step', color=c1)
					ax.hist(X2[i], bins=50, normed=True, range=ranges[i],
							histtype='step', color=c2)
					ax.set_xlim(ranges[i])
				else:
					if i>j:
						A = X1[j]
						B = X1[i]
						ax.set_xlim(ranges[j])
						ax.set_ylim(ranges[i])
						cm = cmap[0]
						ax.hist2d(A, B, range=[ranges[j], ranges[i]],
								 cmap=cm, bins=50, normed=True)
					else:
						A = X2[j]
						B = X2[i]
						ax.set_xlim(ranges[j])
						ax.set_ylim(ranges[i])
						cm = cmap[1]
						ax.hist2d(A, B, range=[ranges[j], ranges[i]],
								 cmap=cm, bins=50, normed=True)
					#H, xb, yb = np.histogram2d(A, B,
					#							bins=20, normed=True)

					# solve 70% level
					#level, maxH = find_level(H, 0.7)
					#ax.contourf(H.T,10,
					#			extent=[xb[0],xb[-1],yb[0],yb[-1]])
					#,levels=[level,maxH], alpha=0.5)

				if i==ndims-1:
					ax.set_xlabel(name[j])
				else:
					ax.set_xticks([])
				if j==0:
					ax.set_ylabel(name[i])
				else:
					ax.set_yticks([])

	def get_data(ds):
		M = 1.3
		sqrts = ds.attrs['sqrts']
		T = ds.attrs['T']
		dt = ds.attrs['dt']
		E = sqrts/2.*(1.+M*M/sqrts**2)
		y0 = np.log(E/M + np.sqrt(1.+E*E/M/M))
		sqrts = E + np.sqrt(E**2-M**2)
		s = sqrts**2
		pmax = (sqrts**2-M*M)/2./sqrts

		p3 = ds['p3'].value
		p4 = ds['p4'].value
		k = ds['k'].value

		k0 = k.T[0]
		kz = k.T[3]
		kt = np.sqrt(k.T[1]**2 + k.T[2]**2)
		etak = 0.5*np.log((k0+kz)/(k0-kz))
		xk = (k0+kz)/sqrts
		cos4k = np.dot(k.T[1:], p4.T[1:], axis=0)/k0/p4.T[0]
		qperp = np.sqrt(p4.T[1]**2 + p4.T[2]**2)
		Mt = (p4.T[0]-pmax)**2 - p4.T[1]**2 - p4.T[2]**2 - (p4.T[3]+pmax)**2
		Tp4 = np.array([projector(ip[1:]) for ip in p4])
		direction = np.array([[0,0,-1] for ip in p4])
		vec1 = np.array([np.dot(PP, vv) for PP, vv in zip(Tp4, direction)])
		vec2 = np.array([np.dot(PP, vv[1:]) for PP, vv in zip(Tp4, k)])
		c4k = np.array([np.dot(v1, v2)/np.sqrt(np.dot(v1, v1)*np.dot(v2, v2))
						for v1, v2 in zip(vec1, vec2)])

		#tauf = 2*k0*(1.-xk)/(kt*kt + xk**2*M**2 + (1-xk)*0.5*9.*T*T)

		#return np.array([np.log(qperp/T), np.log(kt/qperp), np.log(tauf),
		# np.arccos(c4k)])
		return np.array([np.log(qperp/T), np.log(kt/T), etak, np.arccos(c4k)])
	f = h5py.File('data/x-ps.hdf5', 'r')
	fig, axes = plt.subplots(nrows=4, ncols=4,
							 figsize=(columnwidth, columnwidth))
	X1 = get_data(f['23-ps-2'])
	X2 = get_data(f['23-ps-1'])
	ranges = [[-2,3],[-5,5],[-5,5],[0,np.pi]]
	corner(X1, X2, axes, co, cb, ['Oranges', 'Blues'], ranges)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def thermalization(quark):
	mass = 1.3 if quark == 'charm' else 4.2
	def norm_boltzmann(T):
		E = np.linspace(1, 10, 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return np.sum(dfdE)*(E[1]-E[0])
	def thermal_dfdE(T):
		E = np.linspace(1, 10., 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return E, dfdE/norm_boltzmann(T)
	def S_diff(E, T):
		values = np.log(norm_boltzmann(T)) + E/T
		return np.mean(values), np.std(values)/np.sqrt(len(E)*1.)
	def S_same(T):
		E = np.linspace(1, 10., 1000)*mass
		norm = norm_boltzmann(T)
		y = (E/T + np.log(norm))*np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi/norm
		return np.sum(y)*(E[1]-E[0])
	def get_xy(ds):
		E0 = ds.attrs['E']
		Temp = ds.attrs['T']
		dt = ds.attrs['dt']
		S0 = S_same(Temp)
		tarray = (np.array(range(len(ds.value)))+1.)*dt
		sarray = np.array([S_diff(si, Temp) \
							for si in ds.value[::5,:,0]]).T
		return tarray[::5], sarray[0]-S0, sarray[1]

	fig, axes1 = plt.subplots(nrows=1, ncols=1,
							 figsize=(columnwidth, columnwidth))
	f = h5py.File(quark+"-data/thermalization.hdf5", 'r')
	left, bottom = 0.5, 0.35
	width, height = 0.4, 0.3
	axes2 = fig.add_axes([left, bottom, width, height])
	for name, fmt, c, label in \
		zip(['T300E10-22', 'T300E10-22-23', 'T300E10-22-23-32'],
			[':', '--', '-'], [cr, cg, cb],
			['Elastic', 'Elastic + rad.',
			'Elastic + rad. + abs.']):
		t, S, dS = get_xy(f[name])
		for ia, (ax, ylim) in enumerate(zip([axes1,axes2], [[-2,30], [-1,2]])):
			ax.plot(t, S, fmt, color=c, label=label)
			ax.fill_between(t, S-dS*2, S+dS*2, color=c, alpha=0.4)
			ax.set_ylim(*ylim)
			ax.plot(t, np.zeros_like(t),'k:')
			if ia==1:
				ax.set_xticks([0,100])
				ax.set_yticks([-1,0,1,2])
			else:
				ax.legend()
				ax.set_title(r"$E_0 = 10.0$ [GeV], $T = 0.3$ [GeV]")
				ax.set_ylabel(r'$\Delta S$')
				ax.set_xlabel(r'$t$ [fm/c]')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def hybrid_thermalization(quark):
	mass = 1.3 if quark == 'charm' else 4.2
	def norm_boltzmann(T):
		E = np.linspace(1, 10, 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return np.sum(dfdE)*(E[1]-E[0])
	def thermal_dfdE(T):
		E = np.linspace(1, 10., 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return E, dfdE/norm_boltzmann(T)
	def S_diff(E, T):
		values = np.log(norm_boltzmann(T)) + E/T
		return np.mean(values), np.std(values)/np.sqrt(len(E)*1.)
	def S_same(T):
		E = np.linspace(1, 10., 1000)*mass
		norm = norm_boltzmann(T)
		y = (E/T + np.log(norm))*np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi/norm
		return np.sum(y)*(E[1]-E[0])
	def get_xy(ds):
		E0 = ds.attrs['E']
		Temp = ds.attrs['T']
		dt = ds.attrs['dt']
		S0 = S_same(Temp)
		tarray = (np.array(range(len(ds.value)))+1.)*dt
		sarray = np.array([S_diff(si, Temp) \
							for si in ds.value[::5,:,0]]).T
		return tarray[::5], sarray[0]-S0, sarray[1]

	fig, axes = plt.subplots(nrows=2, ncols=1,
							 figsize=(columnwidth, columnwidth))
	f = h5py.File("hybrid_thermalization.hdf5", 'r')

	for name, fmt, c, label in \
		zip(['T300E10-lgv', 'T300E10-elastic', 'T300E10-lgv-B-elastic'],
			[':', '--', '-', '-.'], [cr, cg, cb, co],
			['Diffusion', 'Diff + elastic', 'Diff-B + elastic']):
		t, S, dS = get_xy(f[name])
		for ia, (ax, ylim) in enumerate(zip(axes, [[-2,30], [-1,2]])):
			ax.plot(t, S, fmt, color=c, label=label)
			ax.fill_between(t, S-dS*2, S+dS*2, color=c, alpha=0.4)
			ax.set_ylim(*ylim)
			ax.plot(t, np.zeros_like(t),'k:')
			if ia==1:
				ax.set_xlabel(r'$t$ [fm/c]')
				ax.annotate(r"$E_0 = 10.0$ [GeV]" + "\n"	\
							+"$T = 0.3$ [GeV]", xy=(80,-0.8))
			else:
				ax.legend(loc='upper right')
			ax.set_ylabel(r'$\Delta S$')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])


@plot
def static_process(quark):
	mass = 1.3 if quark == 'charm' else 4.2
	def norm_boltzmann(T):
		E = np.linspace(1, 4, 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return np.sum(dfdE)*(E[1]-E[0])
	def thermal_dfdE(T):
		E = np.linspace(1, 4., 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return E, dfdE/norm_boltzmann(T)

	fig, axes = plt.subplots(nrows=3, ncols=1, sharex=True, sharey=True,
							 figsize=(columnwidth, columnwidth*1.3))
	f = h5py.File(quark+"-data/thermalization.hdf5", 'r')
	labels = ['Elastic', 'Elastic + rad.', 'Elastic + rad. + abs.']
	labels2 = [r'$t = 1$ [fm/c]', r'$t = 10$ [fm/c]', \
				r'$t = 50$ [fm/c]', r'$t = 150$ [fm/c]']
	names = ['T300E10-22', 'T300E10-22-23', 'T300E10-22-23-32']
	colors = [cr, co, cg, cb]
	times = [1, 9, 99, 299]
	for i in range(3):
		ds = f[names[i]]
		E0 = ds.attrs['E']
		Temp = ds.attrs['T']
		dt = ds.attrs['dt']
		ax = axes[i]
		ax.plot([E0, E0], [0.0, 1.5], 'k-', label="Initial" if i==0 else '')
		ax.plot(*thermal_dfdE(Temp), 'k--', label="Boltzmann, $T = 0.3$ [GeV]"\
		 													if i==0 else '')
		ax.set_title(labels[i])
		for j in range(4):
			E = ds.value[times[j],:,0]
			ax.hist(E, range=[1.3, 11], bins=100, normed=True,
					histtype='step', color=colors[j],
					label=labels2[j] if i==2 else '')
		ax.legend(fontsize=textiny)
		ax.set_xlim(mass-0.1,11)
		ax.set_ylim(0,2)
		if i==2:
			ax.set_xlabel(r'$E$ [GeV]')
		if i==1:
			ax.set_ylabel(r'$df/dE$ [GeV${}^{-1}$]')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def static_hybrid_process(quark):
	mass = 1.3 if quark == 'charm' else 4.2
	def norm_boltzmann(T):
		E = np.linspace(1, 4, 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return np.sum(dfdE)*(E[1]-E[0])
	def thermal_dfdE(T):
		E = np.linspace(1, 4., 1000)*mass
		dfdE = np.exp(-E/T)*E*np.sqrt(E**2-mass**2)*4.*np.pi
		return E, dfdE/norm_boltzmann(T)

	fig, axes = plt.subplots(nrows=2, ncols=1, sharex=True, sharey=True,
							 figsize=(columnwidth, columnwidth))
	f = h5py.File("hybrid_thermalization.hdf5", 'r')
	labels = ['Diffusion-A', 'Diffusion-B', 'Diff + el', 'Diff + el + inelastic']
	labels2 = [r'$t = 1$ [fm/c]', r'$t = 5$ [fm/c]', \
				r'$t = 20$ [fm/c]', r'$t = 100$ [fm/c]']
	names = ['T300E10-lgv', 'T300E10-lgv-B'] #, 'T300E10-22', 'T300E10-lgv-elastic', 'T300E10-lgv-elastic-23-32']
	colors = [cr, co, cg, cb]
	times = [1, 9, 39, 199]
	for i, ax in enumerate(axes):
		ds = f[names[i]]
		E0 = ds.attrs['E']
		Temp = ds.attrs['T']
		dt = ds.attrs['dt']
		ax.plot([E0, E0], [0.0, 10], 'k-', label="Initial" if i==0 else '')
		ax.plot(*thermal_dfdE(Temp), 'k--', label="Boltzmann, $T = 0.3$ [GeV]"\
		 													if i==0 else '')
		ax.set_title(labels[i])
		for j in range(4):
			E = ds.value[times[j],:,0]
			ax.hist(E, range=[1.3, 11], bins=100, normed=True,
					histtype='step', color=colors[j],
					label=labels2[j] if i==1 else '')
		ax.legend(fontsize=textiny)
		ax.set_xlim(mass-0.1,11)
		ax.set_ylim(0,2)
		if i==1:
			ax.set_xlabel(r'$E$ [GeV]')
		if i==1:
			ax.set_ylabel(r'$df/dE$ [GeV${}^{-1}$]')
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.98, 0.98])

@plot
def avg_alphas(quark):
	def get_a(muset):
		name = 'Rates-tab'
		f = h5py.File(quark+'-data/avg-alpha_s/RQq2Qq-{}.hdf5'.format(muset), 'r')
		R0 = f[name].value
		f = h5py.File(quark+'-data/avg-alpha_s/RQg2Qg-{}.hdf5'.format(muset), 'r')
		R0 += f[name].value
		f = h5py.File(quark+'-data/avg-alpha_s/aRQq2Qq-{}.hdf5'.format(muset), 'r')
		aR0 = f[name].value
		f = h5py.File(quark+'-data/avg-alpha_s/aRQg2Qg-{}.hdf5'.format(muset), 'r')
		aR0 += f[name].value

		NT = f[name].attrs['N_T']
		TH = f[name].attrs['T_high']
		TL = f[name].attrs['T_low']
		NE = f[name].attrs['N_E1']
		EH = f[name].attrs['E1_high']
		EL = f[name].attrs['E1_low']
		T = np.linspace(TL, TH, NT)
		E = np.linspace(EL, EH, NE)
		mE, mT = np.meshgrid(E, T)
		mE = mE.T
		mT = mT.T
		return mE, mT, aR0/R0

	from matplotlib import cm
	from mpl_toolkits.mplot3d import Axes3D
	fig = plt.figure(figsize=(columnwidth, columnwidth))
	ax = fig.add_subplot(1, 1, 1, projection='3d')

	for muset, cmm in zip(['1piT', '2piT', '4piT'], ['Red', 'Green', 'Blue']):
		E, T, data = get_a(muset)
		ax.plot_surface(np.log10(E), T, data, rstride=1, cstride=1,
						color=cmm, alpha=0.4,
                        linewidth=0, antialiased=False)
	ax.set_xlabel(r'$E$ [GeV]')
	ax.set_ylabel(r'$T$ [GeV]')
	ax.set_zlim(0, 1.0)
	ax.set_zlabel(r'$\langle\alpha_s(\mu^2)\rangle$')
	ax.set_xticks([np.log10(1.3),np.log10(10),np.log10(100)])
	ax.set_yticks([0.2, 0.4, 0.6])
	ax.set_xticklabels(['1.3', '10', '100'])
	ax.view_init(5, 150)
	ax.text(1, 0.8, 0.33, r"$n=1$", (-1,0 ,0), fontsize=8)
	ax.text(1, 0.8, 0.225, r"$n=2$", (-1,0,0), fontsize=8)
	ax.text(1, 0.8, 0.12, r"$n=4$", (-1, 0,0), fontsize=8)
	fig.subplots_adjust(left=0.05, right=0.85, top=0.9)
	ax.set_title(r'Rate averaged $\alpha_s(\mu)$, screened propagator' + '\n'\
		+ r'$\mu=\mathrm{max}\{Q, n\pi T\}$')
@plot
def Rscale(quark):
	def get_R(muset):
		name = 'Rates-tab'
		f = h5py.File(quark+'-data/avg-alpha_s/RQq2Qq-{}.hdf5'.format(muset), 'r')
		R = f[name].value
		f = h5py.File(quark+'-data/avg-alpha_s/RQg2Qg-{}.hdf5'.format(muset), 'r')
		R += f[name].value
		NT = f[name].attrs['N_T']
		TH = f[name].attrs['T_high']
		TL = f[name].attrs['T_low']
		NE = f[name].attrs['N_E1']
		EH = f[name].attrs['E1_high']
		EL = f[name].attrs['E1_low']
		T = np.linspace(TL, TH, NT)
		E = np.linspace(EL, EH, NE)
		mE, mT = np.meshgrid(E, T)
		mE = mE.T
		mT = mT.T
		return mE, mT, R

	from matplotlib import cm
	from mpl_toolkits.mplot3d import Axes3D
	fig = plt.figure(figsize=(columnwidth, columnwidth))
	ax = fig.add_subplot(1, 1, 1, projection='3d')

	E, T, R1 = get_R('1piT')
	E, T, R2 = get_R('2piT')
	E, T, R4 = get_R('4piT')
	ax.plot_surface(np.log10(E), T, R1/R2, rstride=1, cstride=1,
							color='red', alpha=0.5,
	                       linewidth=0, antialiased=False)
	ax.plot_surface(np.log10(E), T, R2/R2, rstride=1, cstride=1,
							color='green', alpha=0.5,
	                       linewidth=0, antialiased=False)
	ax.plot_surface(np.log10(E), T, R4/R2, rstride=1, cstride=1,
							color='blue', alpha=0.5,
	                       linewidth=0, antialiased=False)
	ax.set_xlabel(r'$E$ [GeV]')
	ax.set_ylabel(r'$T$ [GeV]')

	ax.set_zlim(0, 3.0)
	ax.set_zlabel(r'$R(n \pi T)/R(2\pi T)$')
	ax.set_xticks([np.log10(1.3),np.log10(10),np.log10(100)])
	ax.set_yticks([0.2, 0.4, 0.6])
	ax.set_xticklabels(['1.3', '10', '100'])
	ax.view_init(5, 150)
	ax.text(1., 0.8, 1.4, r"$n=1$", (1,0,0), fontsize=8)
	ax.text(1., 0.8, 1.0, r"$n=2$", (1,0,0), fontsize=8)
	ax.text(1., 0.8, 0.6, r"$n=4$", (1,0,0), fontsize=8)
	fig.subplots_adjust(left=0.02, right=0.85, top=0.92, bottom=0.02)
	ax.set_title('Change of scattering rates varying scales' + '\n'\
		+ r'$\alpha_s (\mu = \mathrm{max}\{Q, n\pi T\} )$')

@plot
def Box_Raa(quark):
	def dN_dp_init(quark, pabs):
		# https://arxiv.org/pdf/1205.2396.pdf
		Lambda = 2.1 if quark == 'charm' else 7.5 # [GeV]
		power = 3.9 if quark == 'charm' else 3.9#4.9
		return pabs/(pabs**2+Lambda**2)**power

	def plot_1Raa(quark, ax, type, c, label):
		mass = 1.3 if quark == 'charm' else 4.2
		f = h5py.File(quark+"-data/{}-Box-Raa.hdf5".format(quark), 'r')
		y = []
		for pre in ['0d5piT-', 'piT-', '2piT-']:
			p0abs, p1abs = f[pre+type].value.T
			W = dN_dp_init(quark, p0abs)
			H00, bins = np.histogram(p0abs, 50, weights=W, normed=True, range=[0,105])
			H1, bins = np.histogram(p1abs, 50, weights=W, normed=True, range=[0,105])
			x = (bins[1:] + bins[:-1])/2.
			norm = dN_dp_init(quark, np.linspace(0,100,2000)).sum()*100./2000.
			H0 = np.array([dN_dp_init(quark,
					np.linspace(bins[i], bins[i+1], 20)).mean()/norm
							for i in range(len(x))])
			y.append(H1/H00)
		ax.fill_between(x, y[0], y[2],
						facecolor='white' if '23' not in type else c,
						edgecolor=c,
						hatch='///' if '23' not in type else '',
						alpha=0.5,
						label=label if quark == 'bottom' else '')
		names = [r'$\mu=0.5\pi T$',r'$\mu=\pi T$',r'$\mu=2\pi T$']
		ax.plot(x, y[0],'-', color=c, label=names[0] if quark == 'charm' and type == 'T3004fm-22' else '')
		ax.plot(x, y[1],'--', color=c, label=names[1] if quark == 'charm' and type == 'T3004fm-22' else '')
		ax.plot(x, y[2],':', color=c, label=names[2] if quark == 'charm' and type == 'T3004fm-22' else '')
		ax.set_ylim(0, 1.2)
		ax.legend(fontsize=12, loc='upper right')
		if quark=='charm':
			ax.set_ylabel(r'$R_{AA}$, quark', fontsize=15)
			ax.annotate('Charm\n'+ r'$\frac{dN}{dp_T^2}\propto \frac{1}{\left(p_T^2 + 2.1^2\right)^{3.9}}$',
			 			xy=(40, 0.15), fontsize=15)
		else:
			ax.annotate('Bottom\n'+ r'$\frac{dN}{dp_T^2}\propto \frac{1}{\left(p_T^2 + 7.5^2\right)^{3.9}}$',
			 			xy=(40, 0.15), fontsize=15)
		ax.set_xlabel(r'$p_T$ [GeV]', fontsize=15)

	# plots
	fig, axes = plt.subplots(nrows=1, ncols=2, sharex=True, sharey=True,
							 figsize=(textwidth, columnwidth*1.3))
	for quark, ax in zip(['charm', 'bottom'], axes):
		plot_1Raa(quark, ax,'T3004fm-22', cr, label='Elastic')
		plot_1Raa(quark, ax,'T3004fm-22-23', cb, label='Elastic+inelastic')
	plt.subplots_adjust(wspace=0.)
	plt.suptitle(r'$T=0.3$' +' GeV' + r', $\Delta t=4$' +' fm/c', fontsize=15)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.95, 0.95])

@plot
def Raa_32(quark):
	def dN_dp_init(quark, pabs):
		# https://arxiv.org/pdf/1205.2396.pdf
		Lambda = 2.1 if quark == 'charm' else 7.5 # [GeV]
		power = 3.9 if quark == 'charm' else 4.9#4.9
		return pabs/(pabs**2+Lambda**2)**power

	def plot_1Raa(quark, ax, type, c, l, label):
		mass = 1.3 if quark == 'charm' else 4.2
		f = h5py.File(quark+"-data/{}-Box-Raa.hdf5".format(quark), 'r')
		y = []
		for pre in ['2piT-']:
			p0abs, p1abs = f[pre+type].value.T
			W = dN_dp_init(quark, p0abs)
			H00, bins = np.histogram(p0abs, 50, weights=W, normed=True, range=[0,105])
			H1, bins = np.histogram(p1abs, 50, weights=W, normed=True, range=[0,105])
			x = (bins[1:] + bins[:-1])/2.
			norm = dN_dp_init(quark, np.linspace(0,100,2000)).sum()*100./2000.
			H0 = np.array([dN_dp_init(quark,
					np.linspace(bins[i], bins[i+1], 20)).mean()/norm
							for i in range(len(x))])
			y.append(H1/H00)
		"""
		ax.fill_between(x, y[0], y[2],
						facecolor='white' if '23' not in type else c,
						edgecolor=c,
						hatch='///' if '23' not in type else '',
						alpha=0.5,
						label=label if quark == 'bottom' else '')
		"""
		ax.plot(x, y[0],l, color=c, label=label)
		ax.set_ylim(0, 1.2)
		ax.legend(fontsize=12, loc='upper right')
		if quark=='charm':
			ax.set_ylabel(r'$R_{AA}$, quark', fontsize=15)
			ax.annotate('Charm\n'+ r'$\frac{dN}{dp_T^2}\propto \frac{1}{\left(p_T^2 + 2.1^2\right)^{3.9}}$',
			 			xy=(40, 0.15), fontsize=15)
		else:
			ax.annotate('Bottom\n'+ r'$\frac{dN}{dp_T^2}\propto \frac{1}{\left(p_T^2 + 7.5^2\right)^{4.9}}$',
			 			xy=(40, 0.15), fontsize=15)
		ax.set_xlabel(r'$p_T$ [GeV]', fontsize=15)

	# plots
	fig, axes = plt.subplots(nrows=1, ncols=1, sharex=True, sharey=True,
							 figsize=(columnwidth*1.3, columnwidth*1.3))
	for quark, ax in zip(['charm'], [axes]):
		plot_1Raa(quark, ax,'T3004fm-22', cr, '--',label='Elastic')
		plot_1Raa(quark, ax,'T3004fm-22-23', cb, '-', label='Elastic+23')
		plot_1Raa(quark, ax,'T3004fm-22-23-32', cb, ':', label='Elastic+23+32')
	plt.subplots_adjust(wspace=0.)
	plt.suptitle(r'$T=300$' +'[GeV]' + r', $\Delta t=4$' +'[fm/c]', fontsize=15)
	finish(pad=1, h_pad=0.5, w_pad=0.5, rect=[0.02, 0.02, 0.95, 0.95])


@plot
def qhat(dummy):
	def plot(ax, quark, a, b, c):
		M = 1.3 if quark == 'charm' else 4.2
		Lambda = 0.2
		T = np.linspace(0.1, 0.7, 50)
		E = np.linspace(1, 100, 50)*M
		E, T = np.meshgrid(E, T)
		E = E.T
		T = T.T
		qhatT3 = a*(1/T)**2 + b/E/T
		D2piT = 8.*np.pi/qhatT3
		ax.plot_surface(np.log10(np.sqrt(E**2-M**2)), T, D2piT, rstride=1, cstride=1,
								color=c, alpha=0.5,
		                        linewidth=0, antialiased=False)
	from matplotlib import cm
	from mpl_toolkits.mplot3d import Axes3D
	fig = plt.figure(figsize=(columnwidth, columnwidth))
	ax = fig.add_subplot(1, 1, 1, projection='3d')
	plot(ax, 'charm', .0, 1.0, 'Blue')
	plot(ax, 'bottom', .0, 1.0, 'Red')
	ax.set_xlabel(r'$p$ [GeV]')
	ax.set_ylabel(r'$T$ [GeV]')
	ax.set_zlabel(r'$\hat{q}/T^3$')
	#ax.set_zlim(0, 15)
	ax.set_xticks([np.log10(1),np.log10(10),np.log10(100)])
	ax.set_yticks([0.2, 0.4, 0.6])
	ax.set_xticklabels(['1', '10', '100'])
	ax.view_init(5, -130)
	plt.show()
	fig.subplots_adjust(left=0.1, right=0.95, top=0.9)

def main(quark):
	parser = argparse.ArgumentParser()
	parser.add_argument('plots', nargs='*')
	args = parser.parse_args()

	if args.plots:
		for i in args.plots:
			if i.endswith('.pdf'):
				name = os.path.basename(i)
				plot_path = os.path.dirname(i)
				i = name[:-4]
			if i in plot_functions:
				plot_functions[i](quark)
				subprocess.call("mv {} {}".format(name, plot_path), shell=True)
			else:
				print('unknown plot:', i)
	else:
		for f in plot_functions.values():
			f(quark)


if __name__ == "__main__":
	main('charm')
